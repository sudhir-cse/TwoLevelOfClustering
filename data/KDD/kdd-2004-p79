Fully Automatic Cross-Associations


Deepayan Chakrabarti
Spiros Papadimitriou
Dharmendra S. Modha§
Christos Faloutsos





Carnegie Mellon University
Pittsburgh, PA, USA

{deepay,spapadim,christos}@cs.cmu.edu
§
IBM Almaden Research Center
San Jose, CA, USA
dmodha@us.ibm.com


ABSTRACT
Large, sparse binary matrices arise in numerous data min-
ing applications, such as the analysis of market baskets, web
graphs, social networks, co-citations, as well as information
retrieval, collaborative filtering, sparse matrix reordering,
etc. Virtually all popular methods for the analysis of such
matrices--e.g., k-means clustering, METIS graph partition-
ing, SVD/PCA and frequent itemset mining--require the
user to specify various parameters, such as the number of
clusters, number of principal components, number of par-
titions, and "support." Choosing suitable values for such
parameters is a challenging problem.
Cross-association is a joint decomposition of a binary ma-
trix into disjoint row and column groups such that the rect-
angular intersections of groups are homogeneous. Start-
ing from first principles, we furnish a clear, information-
theoretic criterion to choose a good cross-association as well
as its parameters, namely, the number of row and column
groups. We provide scalable algorithms to approach the op-
timal. Our algorithm is parameter-free, and requires no user
intervention. In practice it scales linearly with the problem
size, and is thus applicable to very large matrices. Finally,
we present experiments on multiple synthetic and real-life
datasets, where our method gives high-quality, intuitive re-
sults.


This material is based upon work supported by the Na-
tional Science Foundation under Grants No. IIS-9817496,
IIS-9988876, IIS-0083148, IIS-0113089, IIS-0209107 IIS-
0205224 INT-0318547 SENSOR-0329549 EF-0331657IIS-
0326322 by the Pennsylvania Infrastructure Technology Al-
liance (PITA) Grant No. 22-901-0001, and by the Defense
Advanced Research Projects Agency under Contract No.
N66001-00-1-8936. Additional funding was provided by do-
nations from Intel, and by a gift from Northrop-Grumman
Corporation. Any opinions, findings, and conclusions or rec-
ommendations expressed in this material are those of the
author(s) and do not necessarily reflect the views of the Na-
tional Science Foundation, or other funding parties.
An
extended version of this paper is available as technical
report CMU-CALD-04-107.


Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior specific
permission and/or a fee.
KDD'04, August 22­25, 2004, Seattle, Washington, USA.
Copyright 2004 ACM 1-58113-888-1/04/0008 ...$5.00.
Categories and Subject Descriptors
H.1.1 [Systems and Information Theory]: Information
Theory; H.3.1 [Information Storage and Retrieval]: Con-
tent Analysis and Indexing


General Terms
Algorithms, Theory


Keywords
Information Theory, MDL, Cross-Association


1. INTRODUCTION - MOTIVATION
Large, sparse binary matrices arise in many applications,
under several guises. Consequently, because of its impor-
tance and prevalence, the problem of discovering structure
in binary matrices has been widely studied in several do-
mains:(1) Market basket analysis and frequent itemsets: The
rows of the matrix represent customers (or transactions)
and the columns represent products. Entry (i,j) of the
matrix is 1 if customer i purchased product j and 0 oth-
erwise. (2) Information retrieval: Rows correspond to doc-
uments, columns to words and an entry in the matrix repre-
sent whether a certain word is present in a document or not.
(3) Graph partitioning and community detection: Rows and
columns correspond to source and target objects and matrix
entries represent links from a source to a destination. (4)
Collaborative filtering, microarray analysis, and numerous
other applications--in fact, any setting that has a many-
to-many relationship (in database terminology) in which we
need to find patterns.
We ideally want a method that discovers structure in such
datasets and has the following main properties:

(P1) It is fully automatic; in particular, we want a princi-
pled and intuitive problem formulation, such that the
user does not need to set any parameters.

(P2) It simultaneously discovers both row and column groups.

(P3) It scales up for large matrices.


Cross-association and Our Contributions. The funda-
mental question in mining large, sparse binary matrices is
whether there is any underlying structure. In these cases,
the labels (or, equivalently, the ordering) of the rows and
columns is immaterial. The binary matrix contains informa-
tion about associations between objects, irrespective of their




79
Research Track Paper

Row
Clusters




Column Clusters
Original matrix




200
400
600
800
100


200


300


400


500


600


700


800
Row
Clusters




Column Clusters
Search - Iteration 2




200
400
600
800
100


200


300


400


500


600


700


800
Row
Clusters




Column Clusters
Search - Iteration 4




200
400
600
800
100


200


300


400


500


600


700


800
Row
Clusters




Column Clusters
Search - Iteration 6




200
400
600
800
100


200


300


400


500


600


700


800
Row
Clusters




Column Clusters
Search - Iteration 8




200
400
600
800
100


200


300


400


500


600


700


800




(a) Original matrix
(b) Iteration pair 1
(c) Iteration pair 2
(d) Iteration pair 3
(e) Iteration pair 4

Figure 1: Searching for cross-associations: Starting with the original matrix (plot (a)), our algorithm suc-
cessively increases the number of groups. At each stage, starting with the current arrangement into groups,
rows and columns are rearranged to improve the code cost.

labeling. Intuitively, we seek row and column groupings
(equivalently, labellings) that reveal the underlying struc-
ture. We can group rows, based on some notion of "simi-
larity" and we could do the same for columns. Better yet,
we would like to simultaneously find row and column groups,
which divide the matrix into rectangular regions as "similar"
or "homogeneous" as possible. These intersections of row
and column groups, or cross-associations, succinctly sum-
marize the underlying structure of object associations. The
corresponding rectangular regions of varying density can be
used to quickly navigate through the structure of the matrix.
In short, we would like a method that will take as input
a matrix like in Figure 1(a), and will quickly and automat-
ically (i) determine a good number of row groups k and
column groups l and (ii) re-order the rows and columns, to
reveal the hidden structure of the matrix, like in Figure 1(e).

We propose a method that has precisely the above prop-
erties: it requires no "magic numbers," discovers row and
column groups simultaneously (see Figure 1) and scales lin-
early with the problem size. We introduce a novel approach
and propose a general, intuitive model founded on compres-
sion and information-theoretic principles. In particular, un-
like existing methods, we employ lossless compression and
always operate at a zero-distortion level. Thus, we can use
the MDL principle to automatically select the number of row
and column groups. We provide an integrated framework to
automatically find cross-associations. Also, our method is
easily extensible to matrices with categorical values.
In Section 2, we survey the related work. In Section 3,
we formulate our data description model starting from first
principles. Based on this, in Section 4 we develop an effi-
cient, parameter-free algorithm to discover cross-associations.
In Section 5 we evaluate cross-associations demonstrating
good results on several real and synthetic datasets. Finally,
we conclude in Section 6.

2. SURVEY
In general, there are numerous settings where we want to
find patterns, correlations and rules. There are several time-
tested tools for most of these tasks. Next, we discuss several
of these approaches, dividing them broadly into application
domains. However, with few exceptions, all require tuning
and human intervention, thus failing on property (P1).

Clustering. We discuss work in the "traditional" cluster-
ing setting first. By that we mean approaches for grouping
along the row dimension only: given a collection of n points
in m dimensions, find "groupings" of the n points. This
setting makes sense in several domains (for example, if the
m dimensions have an inherent ordering), but it is different
from our problem setting.
Also, most of the algorithms assume a user-given parame-
ter. For example, the most popular approach, k-means clus-
tering, requires k from the user. The problem of finding k is
a difficult one and has attracted attention recently; for ex-
ample X-means [1] uses BIC to determine k. Another more
recent approach is G-means [2], which assumes a mixture of
Gaussians (often a reasonable assumption, but which may
not hold for binary matrices). Other interesting variants
of k-means that improve clustering quality is k-harmonic
means [3] (which still requires k) and spherical k-means (e.g.,
see [4]), which applies to binary data but still focuses on
clustering along one dimension). Finally, there are many
other recent clustering algorithms (CURE [5], BIRCH [6],
Chameleon [7], [8]; see also [9]).
Several of the clustering methods might suffer from the
dimensionality curse (like the ones that require a co-variance
matrix); others may not scale up for large datasets.

Information Co-clustering (ITCC) [10] is a recent algorithm
for simultaneously clustering rows and columns of a nor-
malized contingency table or a two-dimensional probability
distribution. Cross-associations (CA) also simultaneously
group rows and columns of a binary (or categorical) matrix
and, at the surface, bear similarity to ITCC. However, the
two approaches are quite different:
(1) For each rectangular intersection of a row cluster with
a column cluster, CA constructs a lossless code, whereas
ITCC constructs a lossy code that can be thought of as a
rank-one matrix approximation.
(2) ITCC generates a progressively finer approximation
of the original matrix. More specifically, as the number of
row and column clusters are increased, the Kullback-Leibler
divergence (or, KL-divergence) between the original matrix
and its lossy approximation tends to zero. In contrast, re-
gardless of the number of clusters, CA always losslessy trans-
mits the entire matrix. In other words, as the number of
row and column clusters are increased, ITCC tries to sweep
an underlying rate-distortion curve, where the rate depends
upon the number of row and column clusters and distortion
is the KL-divergence between the original matrix and its
lossy approximation. In comparison, CA always operates at
zero distortion.
(3) While both ITCC and CA use alternating minimiza-
tion techniques, ITCC minimizes the KL-divergence between




80
Research Track Paper

the original matrix and its lossy approximation, while CA
minimizes the resulting codelength for the original matrix.
(4) As our key contribution, in CA, we use the MDL prin-
ciple to automatically select the number of row and column
clusters. While MDL is well known for lossless coding which
is the domain of CA, no MDL-like principle is yet known for
lossy coding; for a very recent proposal towards this direc-
tion, see [11]. As a result, selecting the number of row and
column clusters in ITCC is still an art. Note that ITCC
is similar in spirit to the Information Bottleneck formula-
tion [12].
Thus, to the best of our knowledge, our method is the
first to study explicitly the problem of parameter-free, joint
clustering of large binary matrices.

Market-basketanalysis/frequentitemsets. Frequent item-
set mining brought a revolution [13] with a lot of follow-up
work [9, 14]. However, they require the user to specify a
"support." The work on "interestingness" is related [15],
but still does not answer the question of "support."

Information retrieval and LSI. The pioneering method of
LSI [16] uses SVD on the term-document matrix. Again, the
number k of eigenvectors/concepts to keep is up to the user
([16] empirically suggest about 200 concepts). Additional
matrix decompositions include the Semi-Discrete Decompo-
sition (SDD) [17], PLSA [18], the clever use of random pro-
jections to accelerate SVD [19], and many more. However,
they all fail on property (P1).

Graphpartitioning. The prevailing methods are METIS [20]
and spectral partitioning [21]. These approaches have at-
tracted a lot of interest and attention; however, both need
the user to specify k, that is, the number of pieces to break
the graph into. Moreover, they typically also require a mea-
sure of imbalance between the two pieces of each split.

Other domains. Related to graphs in several settings is the
work on conjunctive clustering [22]--which requires density
(i.e., "homogeneity") and overlap parameters--as well as
community detection [23], among many. Finally, there are
several approaches to cluster micro-array data (e.g., [24]).

In conclusion, the above methods miss one or more of our
prerequisites, typically (P1). Next, we present our method.


3. CROSS-ASSOCIATION AND
COMPRESSION
Our goal is to find patterns in a large, binary matrix, with
no user intervention, as shown in Figure 1. How should
we decide the number of row and column groups (k and ,
respectively) along with the assignments of rows/columns to
their "proper" groups?
We introduce a novel approach and propose a general,
intuitive model founded on compression, and more specifi-
cally, on the MDL (Minimum Description Language) prin-
ciple [25]. The idea is the following: the binary matrix rep-
resents associations between objects (corresponding to rows
and columns). We want to somehow summarize these in
cross-associations, i.e., homogeneous, rectangular regions of
high and low densities. At the very extreme, we can have
m×n "rectangles," each really being an element of the orig-
Symbol
Definition
D
Binary data matrix
m, n
Dimensions of D (rows, columns)
k,
Number of row and column groups
k,

Optimal number of groups
(,)
Cross-association
Di,j
Cross-associate (submatrix)
ai, bj
Dimensions of Di,j
n(Di,j)
Number of elements n(Di,j) := aibj
n0(Di,j), n1(Di,j)
Number of 0, 1 elements in Di,j
PDi,j(0), PDi,j(1)
Densities of 0, 1 in Di,j
H(p)
Binary Shannon entropy function
C(Di,j)
Code cost for Di,j
T(D; k, , , )
Total cost for D

Table 1: Table of main symbols.

inal matrix, and having "density" of either 0 or 1. Then,
each rectangle needs no further description. At the other
extreme, we can have one rectangle, with a density in the
range from 0 to 1. However, neither really is a summary of
the data. So, the question is, how many rectangles should
we have? The idea is that we penalize the number of rect-
angles, i.e., the complexity of the data description. We do
this in a principled manner, based on a novel application
of the MDL philosophy (where the costs are based on the
number of bits required to transmit both the "summary" of
the structure, as well as each rectangular region, given the
structure).
This is an intuitive and very general model of the data,
that requires no parameters.
Our model allows us to find
good cross-associations automatically. Next, we describe the
theoretical underpinnings in detail.

3.1 Cross-association
Let D = [di,j] denote a m × n (m,n  1) binary data
matrix. Let us index the rows as 1,2,...,m and columns as
1,2,...,n.
Let k denote the desired number of disjoint row groups
and let denote the desired number of disjoint column groups.
Let us index the row groups by 1,2,...,k and the column
groups by 1,2,..., . Let

 : {1,2,...,m}  {1,2,...,k}

 : {1,2,...,n}  {1,2,..., }

denote the assignments of rows to row groups and columns
to column groups, respectively. We refer to {,} as a
cross-association. To gain further intuition about a given
cross-association, given row groups  and column groups
, let us rearrange the underlying data matrix D such that
all rows corresponding to group 1 are listed first, followed
by rows in group 2, and so on. Similarly, let us rearrange
D such that all columns corresponding to group 1 are listed
first, followed by columns in group 2, and so on. Such a rear-
rangement, implicitly, sub-divides the matrix D into smaller
two-dimensional, rectangular blocks. We refer to each such
sub-matrix as a cross-associate, and denote them as Di,j,
i = 1, . . . , k and j = 1, . . . , . Let the dimensions of Di,j be
(ai,bj).

3.2 A Lossless Code for a Binary Matrix
With the intent of establishing a close connection between
cross-association and compression, we first describe a loss-
less code for a binary matrix. There are several possible
models and algorithms for encoding a binary matrix. With




81
Research Track Paper

hindsight, we have simply chosen a code that allows us to
build an efficient and analyzable cross-association algorithm.
Throughout this paper, all logarithms are base 2 and all code
lengths are in bits.
Let A denote an a × b binary matrix. Define

n1(A) := number of nonzero entries in A

n0(A) := number of zero entries in A

n(A) := n1(A) + n0(A) = a × b

PA(i) := ni(A)/n(A),
i = 0, 1.

Intuitively, we model the matrix A such that its elements
are drawn in an i.i.d. fashion according to the distribution
PA. Given the knowledge of the matrix dimensions (a, b)
and the distribution PA, we can encode A as follows. Scan
A in a fixed, predetermined ordering. Whenever i, i = 0, 1
is encountered, it can be encoded using -log PA(i) bits, on
average. The total number of bits sent (this can also be
achieved in practice using, e.g., arithmetic coding [26, 27,
28]) will be


C(A) :=
1
X

i=0
ni(A)log
,,
n(A)
ni(A)
«
= n(A)H`PA(0)´,
(1)


where H is the binary Shannon entropy function.
For example, consider the matrix



A =
2

6
6
4
1 0 0 0
0 0 1 0
0 1 0 0
0 0 0 1
3

7
7
5
.



In this case, n1(A) = 4, n0(A) = 12, n(A) = 16, PA(1) =
1/4, PA(0) = 3/4. We can encode each 0 element using
roughly log(4/3) bits and each 1 element using roughly log 4
bits. The total code length for A is: 4log 4+12log 4/3 =
16  H(1/4).

3.3 Cross-association and Compression
We now make precise the link between cross-association
and compression. Let us suppose that we are interested in
transmitting (or storing) the data matrix D of size m × n
(m,n  1), and would like to do so as efficiently as possible.
Let us also suppose that we are given a cross-association
(,) of D into k row groups and
column groups, with
none of them empty.
With these assumptions, we now describe a two-part code
for the matrix D. The first part will be a description com-
plexity involved in describing the cross-association (, ).
The second part will be the actual code for the matrix, given
the cross-association.

3.3.1 Description Complexity
The description complexity in transmitting the cross-asso-
ciation shall consist of the following terms:

1. Send the matrix dimensions m and n using, e.g., log (m)+
log (n), where log is the universal code length for
integers1. However, this term is independent of the
cross-association. Hence, while useful for actual trans-
mission of the data, it will not figure in our framework.

1
It can be shown that log (x)  log2(x)+log2 log2(x)+...,
where only the positive terms are retained and this is the
optimal length, if we do not know the range of values for x
beforehand [29]
2. Send the row and column permutations using, e.g.,
m log m and n log n bits, respectively. This term is
also independent of any given cross-association.

3. Send the number of groups (k, ) using log k + log
bits (or alternatively, using log m + log n bits).

4. Send the number of rows in each row group and also
the number of columns in each column group. Let us
suppose that a1  a2  ...  ak  1 and b1  b2 
. . .  b  1. Compute


¯
ai :=
k
X

t=i
at
!
- k + i,
i = 1, . . . , k - 1


¯bj
:=
X

t=j
bt
!
- + j,
j = 1, . . . , - 1.


Now, the desired quantities can be sent using the fol-
lowing number of bits:

k-1
X

i=1
log ¯
ai +
-1
X

j=1
log¯bj .


5. For each cross-associate Di,j, i = 1,...,k and j =
1,..., , send n1(Di,j), i.e., the number of ones in the
matrix, using log(aibj + 1) bits.

3.3.2 The Code for the Matrix
Let us now suppose that the entire preamble specified
above has been sent. We now transmit the each of the
actual cross-associates Di,j, i = 1,...,k and j = 1,..., ,
using C(Di,j) bits according to Eq. 1.

3.3.3 Putting It Together
We can now write the total code length for the matrix D,
with respect to a given cross-association as:

T(D; k, , , ) :=


log k + log
+
k-1
X

i=1
log ¯
ai +
-1
X

j=1
log¯bj



+
k
X

i=1
X

j=1
log(aibj + 1) +
k
X

i=1
X

j=1
C(Di,j), (2)


where we ignore the costs log (m)+log (n) and m log m +
n log n , since they do not depend upon the given cross-
association.

3.4 Problem Formulation
An optimal cross-association corresponds to the number
of row groups k , the number of column groups
, and a
cross-association ( , ) such that the total resulting code
length, namely, T(D;k , , , ) is minimized. Typically,
such problems are computationally hard. Hence, in this pa-
per, we shall pursue feasible practical strategies. To de-
termine the optimal cross-association, we must determine
both the number of row and columns groups and also a
corresponding cross-association. We break this joint prob-
lem into two related components: (i) finding a good cross-
association for a given number of row and column groups;
and (ii) searching for the number of row and column groups.
In Section 4.1 we describe an alternating minimization algo-
rithm to find an optimal cross-association for a fixed number




82
Research Track Paper

Row
Clusters




Column Clusters
Original matrix




100
200
300
400
500
600
50

100

150

200

250

300

350

400

450

500
Row
Clusters




Column Clusters
Iteration 1 (rows)




100
200
300
400
500
600
50

100

150

200

250

300

350

400

450

500
Row
Clusters




Column Clusters
Iteration 2 (cols)




100
200
300
400
500
600
50

100

150

200

250

300

350

400

450

500
Row
Clusters




Column Clusters
Iteration 4 (cols)




100
200
300
400
500
600
50

100

150

200

250

300

350

400

450

500




(a) Original groups
(b) Row shifts (Step 2)
(c) Column shifts (Step 4)
(d) Column shifts (Step 4)

Figure 2: Row and column shifting: Holding k and fixed (here, k = = 3), we repeatedly apply Steps 2 and 4
of ReGroup until no improvements are possible (Step 6). Iteration 3 (Step 2) is omitted, since it performs
no swapping. To potentially decrease the cost further, we must increase k or or both, as in Figure 1.

of row and column groups. In Section 4.2, we outline an ef-
fective heuristic strategy that searches over k and to min-
imize the total code length T. This heuristic is integrated
with the minimization algorithm.


4. ALGORITHMS
In the previous section we established our goal: Among
all possible k and l values, and all possible row- and column-
groups, pick the arrangement with the smallest total com-
pression cost, as MDL suggests (model plus data). Although
theoretically pleasing, Eq. 2 does not tell us how to go about
finding the best arrangement--it can only pinpoint the best
one, among several candidates. The question is how to gen-
erate good candidates.
We answer this question in two steps:

1. ReGroup (inner loop): For a given k and , find a
good arrangement (i.e., cross-association).

2. CrossAssociationSearch (outer loop): Search for
the best k and (k, = 1,2,...), re-using the arrange-
ment so far.
We present each in the following sections.

4.1 Alternating Minimization (ReGroup)
Suppose we are given the number of row groups k and the
number of column groups and are are interested in finding
a cross-association ( , ) that minimizes

k
X

i=1
X

j=1
C(Di,j),
(3)


where Di,j are the cross-associates of D, given ( , ). We
now outline a simple and efficient alternating minimization
algorithm that yields a local minimum of Eq. 3. We should
note that, in the regions we typically perform the search, the
code cost dominates the total cost by far (see also Figure 3
and Section 5.1), which justifies this choice.

Algorithm ReGroup:

1. Let t denote the iteration index. Initially, set t = 0.
Start with an arbitrary cross-association (t,t) of
the matrix D into k row groups and column groups.
For this initial partition, compute the cross-associate
matrices Dti,j, and corresponding distributions PDt
i,j

Pti,j.

2. For this step, we will hold column assignments, i.e.,
t, fixed. For every row x, splice it into parts, each
corresponding to one of the column groups. Denote
them as x1,...,x . For each of these parts, compute
nu(xj), u = 0, 1, and j = 1, . . . , . Now, assign row x
to that row group t
+1
such that, for all 1  i  k:


X

j=1
1
X

u=0
nu(xj)log
1
Pt
t
+1
(x),j
(u)



X

j=1
1
X

u=0
nu(xj)log
1
Pti,j(u)
. (4)


3. With respect to cross-association (t
+1
, t), recom-
pute the matrices Dt
+1
i,j
, and corresponding distribu-
tions PD
t+1
i,j
 Pt
+1
i,j
.

4­5. Similar to steps 2­3, but swapping columns instead
and producing a new cross-association (t
+1
, t
+2
)
and corresponding cross-associates Dt
+2
i,j
with distri-
butions PD
t+2
i,j
 Pt
+2
i,j
.

6. If there is no decrease in total cost, stop; otherwise,
set t = t + 2, go to step 2, and iterate.

Figure 2 shows the alternating minimization algorithm
in action. The graph consists of three square sub-matrices
("caves" [30]) with sizes 280, 180 and 90, plus 1% noise. We
permute this matrix and try to recover its structure. As
expected, for k = = 3, the algorithm discovers the correct
cross-associations. It is also clear that the algorithm finds
progressively better representations of the matrix.

Theorem 4.1 For t  1,

k
X

i=1
X

j=1
C(Dti,j) 
k
X

i=1
X

j=1
C(Dt
+1
i,j
) 
k
X

i=1
X

j=1
C(Dt
+2
i,j
).


In words, ReGroup never increases the objective function
(Eq. 3).

Proof. We shall only prove the first inequality, the sec-
ond inequality will follow by symmetry between rows and
columns.

k
X

i=1
X

j=1
C(Dti,j)



=
k
X

i=1
X

j=1
1
X

u=0
nu(Dti,j)log
1
Pti,j(u)




83
Research Track Paper

0


20


40


60
0
10
20
30
40
50
60
0
1000
2000
3000
4000




l
Total cost vs. #cross-associates




k
cost
(total)




5
10
15
20
25
30
35
40
45
50
55
5
10
15
20
25
30
35
40
45
50
55




k
l
Total cost vs. #cross-associates



3000




3000




(5,3)
3000




3000




500
500
500
1000




1000
1000
1000
1000

1000




1000
1500




1500




1500
1500
1500
1500




1500




1500


1500
2000




2000




2000
2000
2000
2000




2000




2000
2500




2500




2500
2500
2500
2500




2500
3000




3000




3000
3000
3000




3000
3000




·
kl = 1950




kl = 570
kl = 900
kl = 1400




0
10
20
30
40
50
60
0
500
1000
1500
2000
2500
3000
3500
Total cost vs. #cross-associates




k ( = l )
cost
(total)




(a) Total cost (surface)
(b) Total cost (contour)
(c) Total cost (diagonal)




0


20


40


60
0
10
20
30
40
50
60
0
1000
2000
3000
4000




l
Code cost vs. #cross-associates




k
cost
(code)




5
10
15
20
25
30
35
40
45
50
55
5
10
15
20
25
30
35
40
45
50
55




k
l
Code cost vs. #cross-associates



500




500




500


500
500
500
500500
500
500
500
1000




1000




1000

1000
1000
1000
1500




1500




1500

1500
1500
1500
2000




2000




2000

2000
2000
2000
2500




2500




2500

2500
2500
2500
(5,3)
·
0
10
20
30
40
50
60
0
500
1000
1500
2000
2500
3000
3500
Code cost vs. #cross-associates




k ( = l )
cost
(code)




(d) Code cost (surface)
(e) Code cost (contour)
(f) Code cost (diagonal)

Figure 3: General shape of the total cost (number of bits) versus number of cross-associates (synthetic
cave graph with three square caves of sizes 32, 16 and 8, with 1% noise). The "waterfall" shape (with the
description and code costs dominating the total cost in different regions) illustrates the intuition behind our
model, as well as why our minimization strategy is effective.


=
k
X

i=1
X

j=1
1
X

u=0
2

4
X

x:t(x)=i
nu(xj)
3

5log
1
Pti,j(u)


=
k
X

i=1
X

x:t(x)=i
"
X

j=1
1
X

u=0
nu(xj)log
1
Pti,j(u)
#




(a)

k
X

i=1
X

x:t(x)=i
"
X

j=1
1
X

u=0
nu(xj)log
1
Pt
t
+1
(x),j
(u)
#




(b)
=
k
X

i=1
X

x:t
+1
(x)=i
"
X

j=1
1
X

u=0
nu(xj)log
1
Pt
t
+1
(x),j
(u)
#




=
k
X

i=1
X

j=1
1
X

u=0
2

4
X

x:t
+1
(x)=i
nu(xj)
3

5log
1
Pti,j(u)


=
k
X

i=1
X

j=1
1
X

u=0
nu(Dt
+1
i,j
)log
1
Pti,j(u)

(c)

k
X

i=1
X

j=1
1
X

u=0
nu(Dt
+1
i,j
)log
1
Pt
+1
i,j
(u)


=
k
X

i=1
X

j=1
C(Dt
+1
i,j
)


where (a) follows from Step 2 of ReGroup; (b) follows
by re-writing the outer two sums­since i is not used any-
where inside the [···] terms; and (c) follows from the non-
negativity of the Kullback-Leibler distance.


Remarks. Instead of batch updates, sequential updates are
also possible. Also, rows and columns need not alternate
in the minimization. We have many locally good moves
available (based on Theorem 4.1) which require only linear
time.
It is possible that ReGroup may cause some groups to be
empty, i.e., ai = 0 or bj = 0 for some 1  i  m, 1  j  n
(to see that, consider e.g., a homogeneous matrix; then we
always end up with one group). In other words, we may find
k and less than those specified.
Finally, we can easily avoid infinite quantities in Eq. 4 by
using, e.g., (nu(A) + 1/2)/(n(A) + 1) for PA(u), u = 0,1.

Initialization. If we want to use ReGroup (inner loop) by
itself, we have to initialize the mappings (,). For , the
simplest approach is to divide the rows evenly into k initial
"groups," taking them in their original order. For  we do
the initialization in the same manner. This often works well
in practice. A better approach is to divide the "residual
masses" (i.e., marginal sums of each column) evenly among
k groups, taking the rows in order of increasing mass (and
similarly for ). The initialization in Figure 2 is mass-based.
However, our CrossAssociationSearch (outer loop) al-
gorithm, described in the next section, is an even better al-
ternative. We start with k = = 1, increase k and and cre-
ate new groups, taking into account the cross-associations up
to that point. This tightly integrated group creation scheme,
that reuses current ReGroup row and column group assign-
ments, yields much better results.

Complexity. The algorithm is O(n1(D)·(k+ )·I) where I
is the number of iterations. In step (2) of the algorithm, we
access each row and count their nonzero elements (of which
there are n1(d) in total), then consider k possible candidate
row groups to place it into. Therefore, an iteration over rows




84
Research Track Paper

Dataset
Dim. (a × b)
n1(A)
CAVE
810×900
162,000
CAVE-Noisy
810×900
171,741
CUSTPROD
295×30
5,820
CUSTPROD-Noisy
295×30
5,602
NOISE
100×100
952
CLASSIC
3,893×4,303
176,347
GRANTS
13,297×5,298
805,063
EPINIONS
75,888×75,888
508,960
CLICKSTREAM
23,396×199,308
952,580

Table 2: Dataset characteristics.

is O(n1(D)·k). Similarly, an iteration over columns (step 4)
is O(n1(D) · ). There is a total of I/2 row and I/2 column
iterations. All this adds up to O(n1(D) · (k + ) · I).

4.2 Search for k and (CrossAssociationSearch)
The last part of our approach is an algorithm to look for
good values of k and . Based on our cost model (Eq. 2), we
have a way to attack this problem. As we discuss later, the
cost function usually has a "waterfall" shape (see Figure 3),
with a sharp drop for small k and , and an ascent after-
wards. Thus, it makes sense to start with small values of
k, , progressively increase them, and keep rearranging rows
and columns based on fast, local moves in the search space
(ReGroup). We experimented with several search strate-
gies, and obtained good results with the following algorithm.

Algorithm CrossAssociationSearch:

1. Let T denote the search iteration index. Start with
T = 0 and k0 =
0
= 1.

2. [Outer loop] At iteration T, try to increase the num-
ber of row groups. Set kT
+1
= kT + 1. Split the row
group r with maximum entropy per row, i.e.,

r := arg max
1ik
X

1j
n(Di,j)H`PDi,j(0)´
ai
.


Construct an initial label map T
+1
0
as follows: For
every row x in row group r (i.e., for every 1  x  m
such that T(x) = r), place it into the new group kT
+1

(i.e., set T
+1
0
(x) = kT
+1
) if and only if it decreases
the per-row entropy of group r, i.e., if and only if

X

1j
n(Dr,j)H`PD
r,j
(0)´

ar - 1
<
X

1j
n(Dr,j)H`PDr,j(0)´
ar
,

(5)
where Dr,j is Dr,j without row x. Otherwise, we let
T
+1
0
(x) = r = T(x). If we move the row to the new
group, we update Dr,j (for all 1  j  ) by removing
row x (for subsequent estimations of Eq. 5).

3. [Inner loop] Use ReGroup with initial cross-associa-
tions (T
+1
0
, T) to find new ones (T
+1
, T
+1
) and
the corresponding total cost.

4. If there is no decrease in total cost, stop and return
(k,

) = (kT,
T
)--with corresponding cross-associa-
tions (T,T). Otherwise, set T = T+1 and continue.

5­7. Similar to steps 2­4, but trying to increase column
groups instead.


Figure 1 shows the search algorithm in action. Starting
from the initial matrix (CAVES), we successively increase the
number of column and row groups. For each such increase,
the columns are shifted using ReGroup. The algorithm
successfully stops after iteration pair 4 (Figure 1(e)).

Lemma 4.1 If D = [D1D2], then C(D1)+C(D2)  C(D).


Proof. We have

C(D) = n(D)H`PD(0)´ = n(D)H
,,n0(
D)
n(D)
«



= n(D)H
,,PD1(0)
n(D1) + PD2(0)n(D2)
n(D)
«


 n(D1)H`PD1(0)´ + n(D2)H`PD1(0)´

= C(D1) + C(D2),

where the inequality follows from the concavity of H(·)
and the fact that n(D1) + n(D2) = n(D) or n(D1)/n(D) +
n(D2)/n(D) = 1.

Note that the original code cost is zero only for a com-
pletely homogeneous matrix. Also, the code length for (k,l) =
(a,b) is, by definition, zero. Therefore, provided that the
fraction of non-zeros is not the same for every column (and
since H(·) is strictly concave), the next observation follows
immediately.

Corollary 4.1 For any k1  k2 and
1

2
, there exists
cross-associations such that (k1,
1
) leads to a shorter code
(Eq. 3).
By Corollary 4.1, the outer loop in CrossAssociation-
Search decreases the objective cost function. By The-
orem 4.1 the same holds for the inner loop (ReGroup).
Therefore, the entire algorithm CrossAssociationSearch
also decreases the objective cost function (Eq. 3). However,
the description complexity evidently increases with (k, ).
We have found that, in practice, this search strategy per-
forms very well. Figure 3 (discussed in Section 5.1) provides
an indication why this is so.

Complexity. Since at each step of the search we increase ei-
ther k or , the sum k+ always increases by one. Therefore,
the overall complexity of the search is O(n1(D)(k+

)2), if
we ignore the number of ReGroup iterations I (in practice,
I  20 is always sufficient).

5. EXPERIMENTS
We did experiments to answer two key questions: (i) how
good is the quality of the results (which involves both the
proposed criterion and the minimization strategy), and (ii)
how well does the method scale up. To the best of our knowl-
edge, in the literature to date, no other method has been ex-
plicitly proposed and studied for parameter-free, joint clus-
tering of binary matrices.
We used several datasets (see Table 2), both real and syn-
thetic. The synthetic ones were: (1) CAVE, representing a
social network of "cavemen" [30], that is, a block-diagonal
matrix of variable-size blocks (or "caves"), (2) CUSTPROD,
representing groups of customers and their buying prefer-
ences2, (3) NOISE, with pure white noise. We also cre-
ated noisy versions of CAVE and CUSTPROD (CAVE-Noisy and

2
We try to capture market segments with heavily overlap-
ping product preferences, like, say, "single persons", buying
beer and chips, "couples," buying the above plus frozen din-
ners, "families," buying all the above plus milk, etc.




85
Research Track Paper

Row
Clusters




Column Clusters
CAVE - Clustered matrix




200
400
600
800
100


200


300


400


500


600


700


800
Row
Clusters




Column Clusters
CUSTPROD - Clustered matrix




5
10
15
20
25
30
50



100



150



200



250
Row
Clusters




Column Clusters
CAVE-Noisy - Clustered matrix




200
400
600
800
100


200


300


400


500


600


700


800
Row
Clusters




Column Clusters
CUSTPROD-Noisy - Clustered matrix




5
10
15
20
25
30
50



100



150



200



250
Row
Clusters




Column Clusters
NOISE (5%) - Clustered matrix




20
40
60
80
100
10

20

30

40

50

60

70

80

90

100




(a) CAVE
(b) CUSTPROD
(c) CAVE-Noisy
(d) CUSTPROD-Noisy
(e) NOISE (5%)

Figure 4: Cross-associations on synthetic datasets: Our method gives the intuitively correct cross-associations
for (a) CAVE and (b) CUSTPROD. In the noisy versions (c, d), few extra groups are found due to patterns that
emerge, such as the "almost-empty" and "more-dense" cross-associations for pure NOISE (e).

CUSTPROD-Noisy), by adding noise (10% of the number of
non-zeros).
The real datasets are: (1) CLASSIC, Usenet documents
(Cornell's SMART collection [10]), (2) GRANTS, 13,297 doc-
uments (NSF grant proposal abstracts) from several disci-
plines (physics, bio-informatics, etc.), (3) EPINIONS, a who-
trusts-whom social graph of www.epinions.com users [31],
and (4) CLICKSTREAM, with users and URLs they clicked
on [32].
Our implementation was done in MATLAB (version 6.5
on Linux) using sparse matrices. The experiments were per-
formed on an Intel Xeon 2.8GHz machine with 1GB RAM.

5.1 Quality

Total code length criterion. Figure 3 illustrates the in-
tuition behind both our information-theoretic cost model,
as well as our minimization strategy. It shows the general
shape of the total cost (in number of bits) versus the num-
ber of cross-associates. For this graph, we used a "caveman"
matrix with three caves of sizes 32, 16 and 8, adding noise
(1% of non-zeros). We used ReGroup, forcing it to never
empty a group. The slight local jaggedness in the plots is
due to the presence of noise and occasional local minima hit
by ReGroup.
However, the figure reveals nicely the overall, global shape
of the cost function. It has a "waterfall" shape, dropping
very fast initially, then rising again as the number of cross-
associates increases. For small k, , the code cost dominates
the description cost (in bits), while for large k, the descrip-
tion cost is the dominant one. The key points, regarding the
model as well as the search strategies, are:
· The optimal (k,

) is the "sweet spot" balancing these
two. The trade-off between description complexity and
code length indeed has a desirable form, as expected.

· As expected, cost iso-surfaces roughly correspond to k·
= const., i.e., to constant number of cross-associates.

· Moreover, for relatively small (k, ), the code cost clearly
dominates the total cost by far, which justifies our
choice of objective function (Eq. 3).

· The overall, well-behaved shape also demonstrates that
the cost model is amenable to efficient search for a min-
imum, based on the proposed linear-time, local moves.

· It also justifies why starting the search with k = = 1
and gradually increasing them is an effective approach:
we generally find the minimum after a few CrossAs-
sociationSearch (outer loop) iterations.
Clusters
Document class
found
CRANFIELD
CISI
MEDLINE
Precision

1
0
1
390
0.997
2
2
676
9
0.984
3
0
0
610
1.000
4
1
317
6
0.978
5
188
0
0
1.000
6
207
0
0
1.000
7
3
452
16
0.960
8
131
0
0
1.000
9
209
0
0
1.000
10
107
2
0
0.982
11
152
3
2
0.968
12
74
0
0
1.000
13
139
9
0
0.939
14
163
0
0
1.000
15
24
0
0
1.000

Recall
0.996
0.990
0.968



Table 3: The clusters for CLASSIC (see Figure 5(a))
recover the known document classes. Furthermore,
our approach also captures unknown structure (such
as the "technical" and "everyday" medical terms).

Results--synthetic data. Figure 4 depicts the cross-asso-
ciations found by our method on several synthetic datasets.
For the noise-free synthetic matrices CAVE and CUSTPROD, we
get exactly the intuitively correct groups. This serves as a
sanity check for our whole approach (criterion plus heuris-
tics). When noise is present, we find some extra groups
which, on closer examination, are picking up patterns in the
noise. This is expected: it is well known that spurious pat-
terns emerge, even when we have pure noise. Figure 4(e)
confirms it: even in the NOISE matrix, our algorithm finds
blocks of clearly lower or higher density.

Results--real data. Figures 5 and 6 show the cross-asso-
ciations found on several real-world datasets. They demon-
strate that our method gives intuitive results.
Figure 5(a) shows the CLASSIC dataset, where the rows
correspond to documents from MEDLINE (medical jour-
nals), CISI (information retrieval) and CRANFIELD (aero-
dynamics); and the columns correspond to words.
First, we observe that the cross-associates are in agree-
ment with the known document classes (left axis annota-
tions). We also annotated some of the column groups with
their most frequent words. Cross-associates belonging to the
same document (row) group clearly follow similar patterns
with respect to the word (column) groups. For example,
the MEDLINE row groups are most strongly related to the
first and second column groups, both of which are related to
medicine. ("insipidus," "alveolar," "prognosis" in the first
column group; "blood," "disease," "cell," etc, in the second).
Besides being in agreement with the known document
classes, the cross-associates reveal further structure (see Ta-




86
Research Track Paper

500
1000
1500
2000
2500
3000
3500
4000
500
1000
1500
2000
2500
3000
3500




Row
Clusters




Column Clusters
death, prognosis, intravenous
insipidus, alveolar, aortic,
cell, tissue, patient
blood, disease, clinical,




CRANFIELD
MEDLINE




CISI
shape, nasa, leading,
assumed, thin




paint, examination, fall,
raise, leave, based
abstract, notation, works
construct, bibliographies
providing, studying, records,
developments, students,
rules, community
500
1000
1500
2000
2500
3000
3500
4000
4500
5000
2000
4000
6000
8000
10000
12000




Row
Clusters




Column Clusters
encoding, characters,
bind, nucleus,
recombination
plasma, separation, beam
coupling, deposition,
manifolds, operators,
harmonic, operator, topological




meetings, organizations,
session, participating
undergraduate, education,
national, projects




(a) CLASSIC cross-associates (k = 15,

= 19)
(b) GRANTS cross-associates (k = 41,

= 28)

Figure 5: Cross-associations for CLASSIC and GRANTS: Due to the dataset sizes, we show the Cross-associations
via shading; darker shades correspond denser blocks (more ones). We also show the most frequently occurring
words for several of the word (column) groups.

ble 3). For example, the first word group consists of more
"technical" medical terms, while second group consists of
"everyday" terms, or terms that are used in medicine often,
but not exclusively3. Thus, the second word group is more
likely to show up in other document groups (and indeed
it does, although not immediately apparent in the figure),
which is why our algorithm separates the two.
Figure 5(b) shows GRANTS, which consists of NSF grant
proposal abstracts in several disciplines, such as genetics,
mathematics, physics, organizational studies. Again, the
terms are meaningfully grouped: e.g., those related to biol-
ogy ("encoding," "recombination," etc.), to physics ("cou-
pling," "plasma," etc.) and to material sciences.
We present briefly (due to space constraints) experiments
on matrices from other settings: social networks (EPINIONS)
and web visit patterns (CLICKSTREAM). In all cases, our al-
gorithm organizes the matrices in homogeneous regions.

5.2 Scalability
Figure 7 shows wall-clock times (in seconds) of our MAT-
LAB implementation. In all plots, the datasets were cave-
graphs with three caves. For the noiseless case (b), times for
both ReGroup and CrossAssociationSearch increase lin-
early with respect to number of non-zeros. We observe simi-
lar behavior for the noisy case (c). The "sawtooth" patterns
are explained by the fact that we used a new matrix for each
case. Thus, it was possible for some graphs to have differ-
ent "regularity" (spuriously emerging patterns), and thus
compress better and faster. Indeed, when we approximately
scale by the number of inner loop iterations in CrossAsso-
ciationSearch, an overall linear trend (with variance due
to memory access overheads in MATLAB) appears.


6. CONCLUSIONS
We have proposed one of the few methods for clustering
and graph partitioning, that needs no "magic numbers."

· Besides being fully automatic, our approach satisfies
all properties (P1)­(P3): it finds row and column groups
simultaneously and scales linearly with problem size.

3
This observation is also true for nearly all of the (approx-
imately) 600 and 100 words belonging to each group, not
only the most frequent ones shown here.
· We introduce a novel approach and propose a general,
intuitive model founded on compression and information-
theoretic principles.

· We provide an integrated, two-level framework to find
cross-associations, consisting of ReGroup (inner loop)
and CrossAssociationSearch (outer loop).
· We give an effective search strategy to minimize the
total code length, taking advantage of the cost function
properties ("waterfall" shape).
Also, our method is easily extensible to matrices with cate-
gorical values. We evaluate our method on several real and
synthetic datasets, where it produces intuitive results.

7. REFERENCES
[1] D. Pelleg and A. Moore, "X-means: Extending
K-means with efficient estimation of the number of
clusters," in Proc. 17th ICML, pp. 727­734, 2000.
[2] G. Hamerly and C. Elkan, "Learning the k in
k-means," in Proc. 17th NIPS, 2003.
[3] B. Zhang, M. Hsu, and U. Dayal, "K-harmonic
means--a spatial clustering algorithm with boosting,"
in Proc. 1st TSDM, pp. 31­45, 2000.
[4] I. S. Dhillon and D. S. Modha, "Concept decom-
positions for large sparse text data using clustering,"
Mach. Learning, vol. 42, pp. 143­175, 2001.
[5] S. Guha, R. Rastogi, and K. Shim, "CURE: an
efficient clustering algorithm for large databases," in
Proc. SIGMOD, pp. 73­84, 1998.
[6] T. Zhang, R. Ramakrishnan, and M. Livny, "BIRCH:
An efficient data clustering method for very large
databases," in Proc. SIGMOD, pp. 103­114, 1996.
[7] G. Karypis, E.-H. Han, and V. Kumar, "Chameleon:
Hierarchical clustering using dynamic modeling,"
IEEE Computer, vol. 32, no. 8, pp. 68­75, 1999.
[8] A. Hinneburg and D. A. Keim, "An efficient approach
to clustering in large multimedia databases with
noise," in Proc. 4th KDD, pp. 58­65, 1998.
[9] J. Han and M. Kamber, Data Mining: Concepts and
Techniques. Morgan Kaufmann, 2000.
[10] I. S. Dhillon, S. Mallela, and D. S. Modha,
"Information-theoretic co-clustering," in Proc. 9th
KDD, pp. 89­98, 2003.




87
Research Track Paper

1
2
3
4
5
6
7
x 104
1
2
3
4
5
6
7
x 104




Row
Clusters




Column Clusters
Small but dense cluster




2
4
6
8
10
12
14
16
18
x 104
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
2.2
x 104




Row
Clusters




Column Clusters
Small but dense column cluster




1.315
1.316
1.317
1.318
1.319
1.32
1.321
1.322
1.323
1.324
1.325
x 105
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
2.2
x 104




Row
Clusters




Column Clusters

(a) EPINIONS (k = 18,

= 16)(b) CLICKSTREAM (k = 15,

= 13) (c) Blow-up of section in (b)

Figure 6: Cross-associations for EPINIONS and CLICKSTREAM. The matrices are organized successfully
in homogeneous regions. (c) shows that our method captures dense clusters, irrespective of their size.




2+2 3+3 4+4 5+5 6+6 7+7 8+8 9+9 10+1011+11
0
2
4
6
8
10
12
Time vs. k+l




k+l
Time
(sec)
3000 x 1800
2000 x 1200




0
1
2
3
4
5
6
x 106
0
5
10
15
20
25
Time vs. size (noiseless)




# non-zeros
Time
(search)




0
1
2
3
4
5
x 10
0
2
4
6
8
10




Time
(k,l=3,3)




0
1
2
3
4
5
6
x 106
0
200
400
600
800
1000
1200
Time vs. size (1% noise)




# non-zeros
Time
(search)




(4,4)
(8,6)
(7,7)(6,7)
(11,7)(8,10)
(13,8)


(9,8)
(13,9)



(9,10)




0
1
2
3
4
5
x 10
0
2
4
6
8
10
12




Time
(k,l=3,3)




0
1
2
3
4
5
6
x 106
0
5
Time vs. size (1% noise)




# non-zeros
Time
(search)
/
i
(k
i
+l
i
)




(4,4)
(8,6)
(7,7)
(6,7)
(11,7)
(8,10)
(13,8)
(9,8)
(13,9)
(9,10)




0
1
2
3
4
5
x 10
0
2




Time
(k,l=3,3)
/(3
+3)




(a) Time vs. k +
(b) Noiseless
(c) Noisy (1%)
(d) Noisy, scaled

Figure 7: (a) Wall-clock time for one row and column swapping (step (2) and (4)) vs. k + is linear (shown
for two different matrix sizes, with n1(D) = 0.37n(D)). (b,c) Wall-clock time vs. number of non-zeros, for
CrossAssociationSearch (dashed) and for ReGroup with (k,l) = (3,3) (solid). The stopping values (k,

) are
shown on plots (c,d), if different from (3,3). (d) Wall-clock times of plot (c), scaled by  1/(k +

)2.

[11] M. M. Madiman, M. Harrison, and I. Kontoyiannis,
"A minimum description length proposal for lossy
data compression," in Proc. IEEE ISIT, 2004.
[12] N. Friedman, O. Mosenzon, N. Slonim, and N. Tishby,
"Multivariate information bottleneck," in Proc. 17th
UAI, pp. 152­161, 2001.
[13] R. Agrawal and R. Srikant, "Fast algorithms for
mining association rules in large databases," in Proc.
20th VLDB, pp. 487­499, 1994.
[14] J. Han, J. Pei, Y. Yin, and R. Mao, "Mining frequent
patterns without candidate generation: A
frequent-pattern tree approach," Data Min. Knowl.
Discov., vol. 8, no. 1, pp. 53­87, 2004.
[15] A. Tuzhilin and G. Adomavicius, "Handling very large
numbers of association rules in the analysis of
microarray data," in Proc. 8th KDD, 2002.
[16] S. Deerwester, S. T. Dumais, G. W. Furnas, T. K.
Landauer, and R. Harshman, "Indexing by latent
semantic analysis," JASI, vol. 41, pp. 391­407, 1990.
[17] T. G. Kolda and D. P. O'Leary, "A semidiscrete
matrix decomposition for latent semantic indexing
information retrieval," ACM Transactions on
Information Systems, vol. 16, no. 4, pp. 322­346, 1998.
[18] T. Hofmann, "Probabilistic latent semantic indexing,"
in Proc. 22nd SIGIR, pp. 50­57, 1999.
[19] C. H. Papadimitriou, P. Raghavan, H. Tamaki, and
S. Vempala, "Latent semantic indexing: A
probabilistic analysis," in Proc. 17th PODS, 1998.
[20] G. Karypis and V. Kumar, "Multilevel algorithms for
multi-constraint graph partitioning," in Proc. SC98,
pp. 1­13, 1998.
[21] A. Y. Ng, M. I. Jordan, and Y. Weiss, "On spectral
clustering: Analysis and an algorithm," in Proc.
NIPS, pp. 849­856, 2001.
[22] N. Mishra, D. Ron, and R. Swaminathan, "On finding
large conjunctive clusters," in Proc. 16th COLT, 2003.
[23] P. K. Reddy and M. Kitsuregawa, "An approach to
relate the web communities through bipartite graphs,"
in Proc. 2nd WISE, pp. 302­310, 2001.
[24] C. Tang and A. Zhang, "Mining multiple phenotype
structures underlying gene expression profiles," in
Proc. CIKM03, pp. 418­425, 2003.
[25] J. Rissanen, "Modeling by shortest data description,"
Automatica, vol. 14, pp. 465­471, 1978.
[26] J. Rissanen, "Generalized Kraft inequality and
arithmetic coding," IBM J. Res. Dev., vol. 20, no. 3,
pp. 198­203, 1976.
[27] J. Rissanen and G. G. Langdon Jr., "Arithmetic
coding," IBM J. Res. Dev., vol. 23, pp. 149­162, 1979.
[28] I. H. Witten, R. Neal, and J. G. Cleary, "Arithmetic
coding for data compression," Comm. ACM, vol. 30,
no. 6, pp. 520­540, 1987.
[29] J. Rissanen, "Universal prior for integers and
estimation by minimum description length," Annals of
Statistics, vol. 11, no. 2, pp. 416­431, 1983.
[30] D. J. Watts, Small Worlds: The Dynamics of
Networks between Order and Randomness. Princeton
Univ. Press, 1999.
[31] M. Richardson, R. Agrawal, and P. Domingos, "Trust
management for the semantic web," in Proc. 2nd
ISWC, pp. 351­368, 2003.
[32] A. L. Montgomery and C. Faloutsos, "Identifying web
browsing trends and patterns," IEEE Computer,
vol. 34, no. 7, pp. 94­95, 2001.




88
Research Track Paper

