Mining
Optimized
Gain Rules for Numeric
Attributes


Sergey Brin
Rajeev Rastogi
Stanford University,
Palo Alto
Bell Labs, Murray
Hill
sergeyOcs.stanford.edu
rastogiQlucent.com
Kyuseok Shim
Bell Labs, Murray
Hill
shim@lucent.com




Abstract

Association
rules are useful for determining
correlations
between attributes
of a relation
and have applications
in marketing,
financial and retail sectors. Furthermore,
optimized association rules are an effective way to focus
on the most interesting
characteristics
involving
certain
attributes.
Optimized
association rules are permitted
to
contain uninstantiated
attributes
and the problem is to
determine
instantiations
such that either the support,
confidence or gain of the rule is maximized.
In this paper, we generalize the optimized
gain asso-
ciation rule problem by permitting
rules to contain dis-
junctions
over uninstantiated
numeric attributes.
Our
generalized
association rules enable us to extract
more
useful information
about
seasonal and local patterns
involving
the uninstantiated
attribute.
For rules con-
taining
a single numeric attribute,
we present an algo-
rithm with linear complexity
for computing
optimized
gain rules.
Furthermore,
we propose bucketing
tech-
nique that can result in a significant
reduction
in in-
put size by coalescing contiguous
values without
sac-
rificing
optimality.
We also present an approximation
algorithm
based on dynamic programming
for two nu-
meric attributes.
Using recent results on binary space
partitioning
trees, we show that the approximations
are
within
a constant factor of the optimal
optimized
gain
rules.
Our experimental
results for a single numeric
attribute
demonstrate
that our algorithm
scales up lin-
early with the attribute's
domain
size as well as the
number of disjunctions.


1
Introduction

Association
rules, introduced
in [AIS93], provide
a useful mechanism
for discovering
correlations

Permission to make digital or hard copies of all or part of this work fix
personal or classroom USCis granted without fee provided that copies
are not made or distributed for profit or commercial advantage and that
copies hear this notice and the full citation on the first page. To copy
otherwise, to republish, to post on semers or to redistribute to lists.
requires prior specific permission and/or a fee.
KDD-09
San Diego CA USA
Copyright ACM 1999 l-581 13-143-7/99/08...$5.00
among the underlying
data and have applications in
marketing, financial
and retail sectors. In its most
general form, an association
rule can be viewed
as being defined over attributes
of a relation,
and
has the form 12'1 +
C's, where Cr and Cs are
conjunctions
of conditions,
and each condition
is
either Ai = vi or Ai E [Zi,ui] (wi, Zi and `Eliare values
from the domain of the attribute
Ai).
Each rule
has an associated support and confidence. Let the
support of a condition
Ci be the ratio of the number
of tuples satisfying
Ci and the number of tuples
in the relation.
The support of a rule of the form
Cr + C's is then the same as the support of Cr l\Cs,
while its confidence is the ratio of the supports
of conditions
Cr A CZ and Cl.
The association
rules problem is that of computing
all association
rules that satisfy user-specified minimum
support
and minimum
confidence constraints,
and efficient
schemes for this can be found in [AS94, MTV94,
PCY95, SON95, HF95, SA95, SA96].
For example,
consider a relation
in a telecom
service provider
database that
contains
call de-
tail
information.
The attributes
of the rela-
tion are date, time,
src-city,
src-country,
dst-city,
dst-country
and duration.
A single tuple in the
relation
thus captures information
about the two
endpoints
of each call,
as well as the tempo-
ral elements of the call.
The association
rule
(src-city
= NY)
+
(dstrountry
= France)
would
satisfy
the user-specified
minimum
support
and
minimum
confidence of 0.05 and 0.3, respectively,
if at least 5% of total calls are from NY to France,
and at least 30% of the calls that originated
from
NY are to France.


1.1
Optimized
Association
Rules

The optimized
association rules problem, motivated
by applications
in marketing
and advertising,
was
introduced
in [FMMT96b].
An association rule R
has the form (Al
E [I 1,q])
A 15'1-+ CZ, where Al




135

is a numeric attribute,
11and u1 are uninstantiated
variables, and Cl and Cz contain only instantiated
conditions
(that is, the conditions
do not contain
uninstantiated
variables).
Also, the authors define
the gain of rule R, denoted by gain(R),
to be the
difference between the support of (Al E [ll, ~11) A
C~ A Cz and the support of (Al
E [II, ~11) A Cl
times the user-specified minimum
confidence.
The
authors then propose algorithms
for determining
values for the uninstantiated
variables 21and u1 for
each of the following cases:

l
Confidence of R is maximized
and the support
of the condition
(Al E [11,~11) A Cl is at least
the user-specified minimum support (referred to
as the optimized confidence rule).

l
Support of the condition
(Al E [II, ul]) A Cl is
maximized
and confidence of R is at least the
user-specified minimum
confidence (referred to
as the optimized support rule).

l
Gain of R is maximized
and confidence of R is
at least the user-specified minimum
confidence
(referred to as the optimized gain rule).
Optimized
association rules are useful for unrav-
eling ranges for numeric attributes
where certain
trends or correlations are strong (that is, have high
support, confidence or gain). For example, suppose
the telecom service provider mentioned earlier was
interested in offering a promotion
to NY customers
who make calls to France.
In this case, the timing
of the promotion
may be critical
- for its success,
it would be advantageous to offer it close to a pe-
riod of consecutive days in which the percentage of
calls from NY that are directed to France is max-
imum.
The framework
developed in [FMMT96b]
can be used to determine such periods.
Consider,
for example, the association rule (date E [II, ~11) A
src-city
= NY + dst-country
= France. With a min-
imum confidence of 0.5, the optimized
gain rule
results in the period in which the calls from NY
to France exceeds 50% of the total calls from NY,
and furthermore,
the number of these excess calls is
maximum.
A limitation
of the optimized
association rules
dealt with
in [FMMT96b]
is that
only a single
optimal
interval
for a single numeric
attribute
can be determined.
However,
in a number
of
applications,
a single interval may be an inadequate
description
of local trends in the underlying
data.
For example, suppose the telecom service provider is
interested in doing upto Icpromotions for customers
in NY calling France.
For this purpose, we need a
mechanism to identify upto Ic periods during which
a sizeable fraction
of calls are from NY to France.
If association
rules were permitted
to contain
disjunctions
of uninstantiated
conditions,
then we
could determine the optimal k (or fewer) periods by
finding optimal instantiations
for the rule: (date E

bll
v
** . V date
E [Zk, ok]) A srcxity
= NY
+
dst-country
= France.
This information
can be
used by the telecom service provider to determine
the most suitable periods for offering discounts on
international
long distance calls to France.
The
above framework
can be further
strengthened
by
enriching association rules to contain more than one
uninstantiated
attribute
as is done in [FMMT96a].
Thus, optimal
instantiations
for the rule (date E
.
[Zl, ~11 A duration
E [ZI, 611) V . . . V (date E [Zk, ok] A
duration
E [G,&])
+
dst-country
= France would
yield valuable information
about types of calls (in
terms of their duration)
and periods in which a
substantial
portion
of the call volume is directed
to France.
In [RS99], we generalized
the optimized
asso-
ciation
rules problem
for support,
described
in
[FMMT96b].
We allowed association rules to con-
tain upto k disjunctions
over one uninstantiated
nu-
meric attribute.
For one attribute,
we presented
a dynamic programming
algorithm
for computing
the optimized support rule and whose complexity
is
O(n2k), where n is the number of values in the do-
main of the uninstantiated
attribute.
In [RS98a],
we considered a different formulation
of the opti-
mized support problem which we showed to be NP-
hard even for the case of one uninstantiated
at-
tribute.
The optimized
support problem described
in [RS98a] required the confidence over all the opti-
mal regions, considered together, to be greater than
a certain minimum threshold.
Thus, the confidence
of an optimal
region could fall below the thresh-
old and this was the reason for its intractability.
In
[RS99], we redefined the optimized support problem
such that each optimal
region is required to have
the minimum
confidence.
This made the problem
tractable for the one attribute
case.

1.2
Our Contributions
In this paper, we consider the generalized optimized
gain problem. Unlike [FMMT96b]
and [FMMT96a],
we permit
rules to contain
upto
k disjunctions
over one or two uninstantiated
numeric attributes.
Thus, unlike
[FMMT96b]
and [FMMT96a],
that
only compute a single optimal region, our general-
ized rules enable upto k optimal regions to be com-
puted.
Furthermore,
unlike [RS99], in which we only ad-
dressed the optimized support problem, in this pa-
per, we focus on the optimized
gain problem and




136

consider both the one and two attribute
cases. In
addition,
for rules containing
a single numeric at-
tribute,
we develop an algorithm
for computing
the optimized gain rule whose complexity
is O(nk)
where n is the number of values in the domain of
the uninstantiated
attribute
(the dynamic program-
ming algorithm for optimized support that we pre-
sented in [RS99] had complexity
0(n21E)). We also
propose a bucketing optimization
that can result
in significant reductions in input size by coalescing
contiguous values.
For two numeric attributes,
we present a dynamic programming
algorithm
that
computes approximate
association rules. Using re-
cent results on binary space partitioning
trees, we
show that for the optimized gain case, the approx-
imations are within
a constant factor of the opti-
mal solution.
Our experimental
results for a single
numeric attribute
demonstrate that our algorithms
scale up linearly with the attribute's
domain size as
well as the number of disjunctions.
The work reported in this paper has been done in
the context of the SERENDIP
data mining project at
Bell Laboratories (see www.bell-labs.com/projects/
serendip).
Also, proofs of theorems and lemmas
presented in the paper can be found in [RS98b].


2
Preliminaries

In this section, we define the optimized association
rules problem addressed in the paper.
The data
is assumed to be stored in a relation defined over
categorical
and numeric attributes.
Association
rules are built
from
atomic conditions
each of
which has the form Ai = wi (Ai could be either
categorical or numeric), and Ai E [Zi,ui] (only if Ai
is numeric).
For the atomic condition
Ai E [Zi,ui],
if Zi and ui are values from the domain of Ai, the
condition
is referred to as instantiated,
otherwise,
if they are variables, we refer to the condition
as
uninstantiated.
Atomic conditions can be combined using opera-
tors A or V to yield more complex conditions.
In-
stantiated
association rules, that we study in this
paper, have the form Cr + CQ,where Cr and C'sare
arbitrary
instantiated
conditions.
Let the support
for an instantiated
condition C, denoted by sup(C),
be the ratio of the number of tuples satisfying the
condition C and the total number of tuples in the re-
lation.
Then, for the association rule R: Cl + Cz,
sup(R) is defined as sup
and conf(R)
is defined
as
Sup(CIAC*)
SzLP(Cl)
.
Note that our definition
of sup(R)
is different
from the definition
in [AIS93] where
sup(R) was defined to be sup(Cr A Cz).
Instead,
we have adopted the definition
of support used in
[FMMT96b,
FMMT96a,
RS98a, RS99].
Also, let
midonf
denote the user-specified minimum
confi-
dence. Then, gain(R)
is defined to be the difference
between sup(C~ A CZ) and minConf times sz~p(Ci).
In other words, gain(R)
is sup(Cr A&)
- minConf *
sup
= sup(R) * (ccmf(R) - minconf).
The optimized
association rule problem requires
optimal instantiations
to be computed for an unin-
stantiated
association rule that has the form: U A
Cr + C's, where U is a conjunction
of one or two
uninstantiated
atomic conditions
over distinct
nu-
meric attributes,
and Cr and 15'2are arbitrary
in-
stantiated
conditions.
For simplicity,
we assume
that the domain of an uninstantiated
numeric at-
tribute is {1,2,. . . ,n}.
Depending on the number,
one or two, of uninstantiated
numeric attributes,
consider a one or two-dimensional
space with an
axis for each uninstantiated
attribute,
and values
along each axis corresponding
to increasing values
from the domain of the attributes.
Note that if
we consider a single interval in the domain of each
uninstantiated
attribute,
then their combination re-
sults in a region.
For the one-dimensional
case,
this region [Zl, ui] is simply the interval [Zr,ur] for
the attribute;
for the two-dimensional
case, the re-
gion [(Zr,Zz), (ur ,ug)] is the rectangle bounded along
each axis by the endpoints of the intervals [Zr,ur]
and [Zz,~21 along the two axis.
Suppose, for a region R = [ZI, ul],
we define
conf (R), sup(R) and gain(R)
to be ccmf,sup and
gain, respectively, for the rule Al E [II, ul] A Cl +
CZ (similarly,
for R = [(ZI, Z2),(211,uz)], cunf(R),
sup(R) and gain(R)
are defined to be wnf,
sup
and gain for AI E [ZI, ul] AA, E [Zz,2121A Cl -+ C2).
In addition,
for a set of non-overlapping
regions,
S = {RI, Rz, . . . , Rj},
Ri = [Zir, uir], suppose we
define conf(S),
sup(S) and gain(S) to be the conf,
sup and gain, respectively
of the rule Vi=,,Ar
E
[Zir,uir] A Cr + 15'2.For two dimensions, in which
caseeach & = [(&I, b21,(~1, udl,
cd(S),
SUP(S)
and gain(S)
are defined to be the wnf,
sup and
gain, respectively
of the rule Vi==, (Al E [Zil, uil] A
A-J E [Ziz,uiz]) A Cr + CZ. Then, since RI,. . . , Ri
are non-overlapping
regions, the following hold for
set S.

sup(s) = sup(R1) +-a-+
sup(Rj)


conf(S)
=
sup(R1) . conf(R1)
+. **+ sup(Rj) . cmf(Rj)
sup
+ . . . + sup(Rj)

gain(S)
= gain(R1) + . . . + gain(Rj)

Having defined the above notation,
we present
below, the formulation
of the optimized association
rule problem for gain.




137

Given k, determine
a set S containing
at
most Ic regions such that for each region
Ri E S, cunf(Ri)
1 minConf
and gain(S)
is maximized.

We refer to the set S as the optimized gain set.

Example
2.1: Consider the telecom service provider
database (discussed in Section 1) containing call de-
tail data for a one week period.
Figure 1 presents
the summary of the relation for the seven days -
the summary information
includes, for each date,
the total # of calls made on the date, the # of
calls from NY and the # of calls from NY to France.
Also included
in the summary
are the support,
confidence and gain, for each date v, of the rule
date = v A w-city
= NY +
dst-country
= France.
The total number of calls made during the week is
2000.
Suppose we are interested
in discovering
the
interesting periods with heavy call volume from NY
to France (a period is a range of consecutive days).
Then, the following uninstantiated
association rule
can be used.

date E [l, U] A src-city
= NY -+ dst-country
= France

In the above rule,
U is date
E
[Z,U],
Cl
is
src-city
= NY and Cz is d&country
= France.
Let
us assume that
we are interested
in at most 2
periods (that is, Ic = 2) with minConf
= 0.50. The
optimized gain set is { [5,5], [7,7]} - we require upto
two periods such that the percentage of calls during
each of the periods from NY that are to France is
at least 50%, and the gain is maximized.
Of the
possible periods [1,2], [5,5] and [7,7], the gain in
period [1,2] is 0, while the gains for [5,5] and [7,7]
are 12.5 x 10m3 and 2.5 x 10T3, respectively.
Thus,
the optimized gain set is {[5,5], [7,7]}.
I

In the remainder of the paper, we shall assume
that the support,
confidence and gain for every
point
in a region are available
- these can be
computed
by performing
a single pass over the
relation.
The points,
along with their supports,
confidences and gains, thus constitute
the input to
our algorithms.
Thus, the input size is n for the
one-dimensional
case, while for the two-dimensional
case, it is n2.

3
One Numeric
Attribute
In this section, we tackle the problem of comput-
ing the optimized
gain set when association
rules
contain a single uninstantiated
numeric attribute.
Thus, the uninstantiated
rule has the form: (AI E
[Zr,ur]) A Cr + C's, where AI is the uninstantiated
numeric attribute.
We propose an algorithm
with
linear time complexity
for computing the optimized
gain set (containing
upto k non-overlapping
inter-
vals) in Section 3.2. But first, in Section 3.1, we
present preprocessing algorithms for collapsing cer-
tain contiguous ranges of values in the domain of
the attribute
into a single bucket, thus reducing the
size of the input n.

3.1
Bucketing
For the one-dimensional
case, each region is an
interval and since the domain size is n, the number
of possible intervals
is O(n2).
Now, suppose we
could split
the range 1,2,. . . ,n into b buckets,
where b < n, and map every value in Al's domain
into one of the b buckets to which it belongs. Then
the new domain of Al becomes {1,2,. . . ,b} and the
number of intervals to be considered becomes O(b2)
-
which could be much smaller, thus reducing the
time and space complexity
of our algorithms.
Note
that the reduction in space complexity
also results
in reduced memory requirements for our algorithms.
In the following, we present a bucketing algorithm
that 1) does not compromise the optimality
of the
optimized set (that is, the optimized set computed
on the buckets is identical
to the one computed
using the raw domain values), and 2) has time
complexity
O(n).
The output
of the algorithm
is
the b buckets with their supports, confidences and
gains, and this becomes the input to the algorithm
for computing the optimized gain set in Section 3.2.
For optimized gain sets, we begin by making the
following simple observation - values in Al's domain
whose confidence is exactly
minConf
have a gain of
0 and can thus be ignored.
Including
these values
in the optimized gain set does not affect the gain of
the set and so we can assume that for every value
in{1,2,...
,n} , either the confidence is greater than
minConf
or less than minconf.
The bucketing algorithm
for optimized
gain col-
lapses contiguous values whose confidence is greater
than minConf
into a single bucket.
It also com-
bines contiguous
values each of whose confidence
is less than minConf,
into a single bucket.
Thus,
for any interval assigned to a bucket it is the case
that either all values in the interval have confidence
greater than minConf
or all values in the interval
have confidence less than minconf.
For instance, let the domain of Al be {1,2,. . . ,6}
and confidences of 1, 2, 5 and 6 be greater than
minConf,
while confidences of 3 and 4 be less than
minconf.
Then, our bucketing scheme generates 3
buckets - the first containing
values 1 and 2, the




138

Figure 1: Summary of Call Detail Data for a One Week Period



second 3 and 4, and the third
containing
values
5 and 6.
It is straightforward
to observe that
assigning values to buckets can be achieved by
performing
a single pass over the input data and
thus has linear time complexity.
In order to show that
the above bucketing
algorithm
does not violate the optimality
of the
optimized
set, we use the result of the following
theorem.

Theorem
3.1:
Let S be an optimized gain set.
Then, for any interval [u,v] in S, it is the case that
conf([u-l,u-11)
< midonf,
conf([v+l,v+l])
<
minConf,
conf([u,u])
> minConf
and cunf([v,v])
>
minconf.
4

From the above theorem, it follows that if [u, v] is
an interval in the optimized set, then values u and
u - 1 cannot both have confidences greater than
or less than minConf
- the same holds for values
v and v + 1. Thus, for a set of contiguous values
if the confidence of each and every value is greater
than (or is less than) minconf,
then the optimized
gain set either contains all of the values or none of
them. Thus, an interval in the optimized set either
contains all the values in a bucket or none of them
- as a result, the optimized
set can be computed
using the buckets instead of the original values in
the domain.

3.2
Algorithm
for Computing
Optimized
Gain
Set
In this subsection, we present an O(bk) algorithm
for the optimized
gain problem for one dimension.
The
input
to the algorithm
is the b buckets
generated by our bucketing scheme in Section 3.1
along with their confidences, supports and gains.
The problem is to determine a set of at most k
(non-overlapping)
t
al
in erv s such that the confidence
of each interval is greater than or equal to minConf
and gain of the set is maximized.
Note that due to our bucketing algorithm,
buck-
ets adjacent to a bucket with positive
gain have
procedure
optGainlD(l,
b, k)
begin
1. PSet := 0, NSet := {[l,a]}
2. for i := 1 to k {
3.
Let Pq be the interval
in PSet with the smallest
value for gain(min(P,))
4.
Let Nq be the interval
in NSet with the largest
value for gain(maz(Nq))
5.
if gain(min(P,))
+ gain(max(l\r,))
< 0 {
6.
Delete Pq from PSet
7.
Split Pq into three subintervals
(with min(Pp)
as the middle interval)
8.
Insert the first and third intervals to PSet and
second interval to NSet
9.
1
10.
else {
11.
Delete Nq from NSet
12.
Split N,, into three subintervals
(with maz(N,)
as the middle interval)
13.
Insert the first and third intervals to NSet and
the second interval
to PSet
14.
}
15. }
16. return
PSet
end


Figure
2:
Algorithm
for Computing
Optimized
Gain Set



negative gain, and vice versa.
Thus, if there are
at most k buckets with positive gain, then these
buckets constitute
the desired optimized
gain set.
Otherwise,
procedure optGainlD,
shown in Fig-
ure 2, is used to compute the optimized
set. For
an interval I, we denote by max(I),
the subinter-
val of I with maximum
gain. Also, we denote by
m&(l),
the subinterval of I whose gain is minimum.
Note that, for an interval
I, min(1)
and maz(l)
can be computed in time that is linear in the size
of the interval.
This is due to the following
dy-
namic programming
relationship
for the gain of the
subinterval
of I with the maximum gain and end-




139

ing at point u (denoted by maz(u)):
maz(u)
=
m=4win(b,4,
muz(u - 1) + guin([u,u])}.
(A
similar relationship
can be derived for the subin-
terval with minimum gain).
The k desired intervals
are computed
by opt-
GainlD
in k iterations - the ith iteration
computes
the i intervals with the maximum
gain using the
results of the i - lth iteration.
After the i - lth
iteration,
PSet is the optimized
gain set contain-
ing i - 1 intervals,
while the remaining
intervals
not in PSet are stored in NSet. After Pq and Nq
have been computed as described in steps 3-4, if
gain(min(Pq))
+ gain(mas(Nq))
< 0, then it fol-
lows that the gain of min(Pq)
is more negative
than the gain of maz(N,)
is positive.
Thus, the
best strategy
for maximizing
gain is to split Pq
into two subintervals
using min(Pq)
as the split-
ting interval,
and include the two subintervals
in
the optimized
gain set (steps 6-8).
On the other
hand, if guin(min(P,))
+gain(maz(l\r,))
2 0, then
the gain can be maximized by adding maz(N,)
to
the optimized
gain set (steps 11-13).
Note that
if PSet/NSet
is empty, then we cannot compute
P,/N,,
and so gain(min(Pq))/guin(mux(Nq))
in
Step 5 is 0.

Example
3.2: Consider 6 buckets 1,2,. . . ,6 with
gains 10, -15, 20, -15, 20 and -15.
We trace
the execution of optGainlD
assuming that we are
interested
in computing
the optimized
gain set
containing
2 intervals.
Initially,
NSet is set to {[l,S]}.
During the first
iteration
of optGainlD,
Nq is [1,6] since it is the
only interval
in NSet.
Furthermore,
muz(N,)
=
[3,5] and guin(muz(N,))
= 25.
Since PSet is
empty, guin(min(Pq))
= 0 and Nq is split into 3
intervals [1,2], [3,5] and [6,6], of which [3,5] is added
to PSet, and [1,2] and [6,6] are added to NSet (after
deleting [1,6] from it).
In the second iteration,
Pq = [3,5] (min(Pq)
=
[4,4]) and Np = [1,2] (muz(N,)
= [l, 11) (since
Cond
1: Let [u,o] be an interval in PSet. For
all u 5 2 < w, gain@, Z]) 2 0 and gain@, w]) 2
0.

Cond
2: Let [U,IJ] be an interval in NSet. For
all u 5 1 5 V, gain&l])
< 0 (except when
u = 1) and guin([Z, w]) 5 0 (except when v = b).

Cond
3: For all 15 1 < i, 1 5 m 5 j, gain(q)
2 guin(muz(l\r,)).

Cond
4:
For all 1 5 1 5 i, 1 5 m 5 j,
gain(min(Pl))
2 guin(N,)
(except for N,,, that
contain one of the endpoints, 1 or b).

Cond
5:
For all 1 5 Z,m 5 i, 1 #
m,
guin(min(P1))
+ guin(P,)
1 0.

Cond
6:
For all 1 < 1,m 5 j,
I # m,
gain(muz(Nl))
+guin(N,)
5 0 (except for N,
that contain one of the endpoints, 1 or b).
For an interval [u, V] in PSet or NSet, conditions
1 and 2 state properties about the gain of its subin-
tervals that contain u or V. Simply put, they state
that extending
or shrinking
the intervals in PSet
does not cause its gain to increase.
Condition
3
states that the gain of PSet cannot be increased by
replacing an interval
in PSet by one contained in
NSet, while conditions
4 and 5 state that splitting
an interval in PSet and merging two other adjacent
intervals in it or deleting an interval from it, cannot
increase its gain either.
Finally,
Condition
6 cov-
ers the case in which two adjacent intervals in PSet
are merged and an additional
interval from NSet is
added to it - Condition
6 states that these actions
cannot cause PSet's gain to increase.

Lemma
3.3:
After the ith iteration
of procedure
optGainlD,
the intervals
in PSet and NSet satisfy
conditions l-6.
I

We can also show that any set of i intervals (in
PSet) that satisfies all of the 6 above conditions is
optimal with respect to gain.
guin(mus([l,
21)) = 10 is larger than guin(muz([6,6]))
= Lemma
3.4 :
-15).
Thus, sinceguin(min(Pq))+guin(maz(Nq))
=
Any set of i intervals
satisfying

-5, [3,5] is split into 3 intervals [3,3], [4,4] and [5,5],
conditions 1-6 is an optimized gain set. I

of which [3,3] and [5,5] are added to PSet (after
From the above two lemmas, we can conclude
deleting
[3,5] from it), which is the desired opti-
that at the end of the ith iteration,
procedure opt-
mized gain set. I
GainlD
computes the optimized gain set containing
i intervals (in PSet).
We can show that
the above simple
greedy
strategy computes the i intervals with the maximum
gain (in the ith iteration).
We first show that after
Theorem
3.5: Procedure optGainlD
computes the
optimized gain set. 1

the ith iteration,
the intervals
in PSet and NSet
It is straightforward
to observe that the time
satisfy the following
conditions
(let the i intervals
complexity of procedure optGainlD
is O(bk) since it
in PSet be PI,.. . , Pi, and the remaining
intervals
performs k itetitions
and in each iteration,
intervals
in NSet be Ni,...,Nj).
Pq and Nq can be computed in O(b) steps.




140

4
Two Numeric
Attributes
We next consider the problem of mining the opti-
mized gain set for the case when there are two unin-
stantiated numeric attributes.
In this case, we need
to compute a set of k non-overlapping
rectangles
in two-dimensional
space whose gain is maximum.
Unfortunately,
this problem in NP-hard
[KMP98].
In the following
subsection, we describe a dynamic
programming
algorithm with polynomial
time com-
plexity that computes approximations
to optimized
sets.

4.1
Approximation
Algorithm
Using
Dynamic
Programming
The procedure optGain2D
(see Figure 3) for com-
puting
approximate
optimized
gain sets is a dy-
namic programming
algorithm that uses simple end
to end horizontal
and vertical cuts for splitting
each
rectangle into two subrectangles.
Procedure opt-
Gain2D accepts as input parameters, the coordi-
nates of the lower left ((i, j)) and upper right ((p, q))
points of the rectangle for which the optimized set
is to be computed. These two points completely de-
fine the rectangle. The final parameter is the bound
on the number of rectangles that the optimized set
can contain. The array optSet[(i, j), (p, q), k] is used
to store the optimized
set with size at most k for
the rectangle,
thus preventing
recomputations
of
the optimized set for the rectangle. The confidence,
support and gain for each rectangle is precomputed
-
this can be done in O(n4) steps which is propor-
tional to the total number of rectangles possible.
In optGain2D,
the rectangle [(i,j),
(p, q)] is first
split
into
two subrectangles
using vertical
cuts
(steps 6-13), and later horizontal cuts are employed
(steps 14-21).
For k > 1, vertical cuts between i
and i + 1, i + 1 and i + 2, . . ., p - 1 and p are used
to divide rectangle [(i, j), (p, q)] into subrectangles
I(~,~L(4dland[(~+Lj),(p,dl fordi 51 5~1.
For every pair of subrectangles
generated above,
optimized
sets of size kl
and kg are computed
by recursively
invoking
optGain2D
for all k1, kz
such that kl + k2 = k.
An optimization
can be
employed in case k = 1 (Step 7), and instead of
considering
every vertical
cut, it suffices to only
consider the vertical cuts at the ends since the single
optimized
rectangle
must be contained
in either
[(i,j),(p-
l,q)]
or [(i+ l,j),(p,q)].
After similarly
generating
pairs of subrectangles using horizontal
cuts, the optimized
set for the original
rectangle
is set to the union of the optimized
sets for the
pair with the maximum gain (function maxGainSet
returns the set with the maximum gain from among
its inputs).
procedure
optGainaD((i, j), (p, q), k)
begin
1. if optSet[(i,j),
(p, q), k] computed earlier
2.
return
optSetK43, (P,d, 4
3. if conf([(i,j),
(p,q)])
2 minConf
4.
optSetKi,A,b,q),4 := {K&d,b,dlh
5. optSet := optSet. := 0
6.
ifp>i{
7.
ifk=l
8.
optSet = maxGainSet(optGain2D((i,j),
(p - 1,q),
k), wtGain2D((i
+ 1, j), (P, d, k))
9.
else
10.
for 2:= i to p - 1 do
11.
for m := 1 to k - 1 do
12.
optSet = maxGainSet(optSetl,
optGain2D
((4 2, (1,cd,ml U optGain'W(Z + 1,j>, (p, q), k - ml)
13. }
14. ifq>j
{
15.
ifk=l
16.
optSet = maxGainSet(optGainZD((i,j),
(p, q - l),
k), optGainW(i,j
+ 11,hq), k))
17.
else
18.
for I := j to q - 1 do
19.
for m := 1 to k - 1 do
20.
optSet = maxGainSet(optSet2, optGain2D
((Cd, (P,11,m) U optGainZD((i, l+ 11,(P,d, k - ml)
21. }
22. optSet[(i,j), (p,q), k] := maxGainSet(optSet[(i,j),
(P, 4, kl,optSetl,
optSet
23. return
optSet[(i, j), (p, q), k]
end


Figure 3: Dynamic
Programming
Algorithm
for
Computing
Optimized
Gain Set


The number
of points
input
to our dynamic
programming
algorithm
for the two-dimensional
case is N = n2 since n is the size of the domain of
each of the two uninstantiated
numeric attributes.

Theorem
4.1:
The complexity
of Procedure
opt-
Gain2D is O(N2.5k2).
I

4.2
Optimality
Results
Procedure optGain2D's
approach of splitting
each
rectangle into two subrectangles and then combin-
ing the optimized sets for each subrectangle may not
yield the optimized
set for the original
rectangle.
This point is further illustrated
in Figure 4(a) that
shows a rectangle and the optimized set of rectan-
gles for it. It is obvious that there is no way to split
the rectangle into two subrectangles such that each
rectangle in the optimized
set is completely
con-
tained in one of the subrectangles.
Thus, a dynamic
programming
approach that considers all possible




141

(4
(b)
Figure 4: Binary Space Partitionable
Rectangles


splits of the rectangle into two subrectangles (using
horizontal
and vertical end-to-end cuts) and then
combines the optimized
sets for the subrectangles
may not result in the optimized set for the original
rectangle being computed.
In the following,
we first identify restrictions
un-
der which optGain2D
yields optimized
sets.
We
then show bounds on how far the computed ap-
proximation
for the general case can deviate from
the optimal solution.
Let us define a set of rectangles to be binary
space partitionable
if it is possible to recursively
partition
the plane such that no rectangle is cut,
and each partition
contains at most one rectangle.
The set of rectangles in Figure 4(b) is binary space
partitionable
(the bold lines are a partitioning
of
the rectangles) - however, the set in Figure 4(a) is
not.
If we are willing
to restrict
the optimized
set
to only binary space partitionable
rectangles, then
we can show that procedure optGain2D
computes
the optimized
set.
Note that
any set of 3 or
fewer rectangles in a plane is always binary space
partitionable.
Thus,
for t
5
3, optGain2D
computes the optimized gain set.

Theorem
4.2 :
Procedure optGain2D
computes
the optimized
set of binary
space partitionable
rectangles. I

We next use this result in order to show that in
the general case, the approximate
optimized
gain
set computed by procedure optGain2D
is within
a
factor of i of the optimized
gain set. The proof
also uses a result from [AF92], in which it is shown
that for any set of rectangles in a plane, there exists
a binary
space partitioning
(that
is, a recursive
partitioning)
of the plane such that each rectangle
is cut into at most four subrectangles
and each
partition
contains at most one subrectangle.

Theorem
4.3: Procedure optGain2D
computes an
optimized gain set whose gain is greater
than or
equal to a times the gain of the optimized gain set.
I


5
Experiment
al Results

In this section, we study the performance
of our
algorithm for computing optimized gain sets for the
one-dimensional
case. In particular,
we show that
our algorithm
is highly scaleable. For instance, we
can tackle attribute
domains with sizes as high as
one million in a few minutes.
In our experiments,
the data file is read only
once at the beginning in order to compute the gain
for every point.
The time for this, in most cases,
constitutes
a tiny fraction
of the total execution
time of our algorithms.
Thus, we do not include
the time spent on reading
the data file in our
results.
Furthermore,
note that the performance
of our algorithms
does not depend on the number
of tuples in the data file - it is more sensitive to the
size of the attribute's
domain n and the number of
intervals L. We fixed the number of tuples in the
data file to be 10 million in all our experiments.
Our
experiments were performed on a Sun Ultra-2/200
machine with 512 MB of RAM and running Solaris
2.5.



Synthetic
Datasets:
The association rule that
we experimented
with, has the form U A Cr + C's
where U contains
1 uninstantiated
attribute
(see
Section 2) whose domain consists of integers ranging
from 1 to 72. Every domain value (that is, point
in one-dimensional
space) is assigned a randomly
generated confidence between 0 and 1 with uniform
distribution.
Each value is also assigned a randomly
generated support between 0 and 2 with uniform
distribution;
thus, the average support for a value
is h.




142

n
500
1000
2000 1 5000
7500 1 10000
50000 1 100000
b
195
354
738 1 1829
2759 1 3711
16321 1 32266

Table 1: Values of b for different domain sizes


5.1
Bucketing
We begin by studying
the reduction
in input
size due to the bucketing
optimization.
Table 1
illustrates
the number of buckets for domain sizes
ranging from 500 to 100,000 when minConf is set to
0.5. From the table, it follows that bucketing can
result in reductions to input size as high as 65%.

5.2
Scale-up
with
n
The graph in Figure 5(a) plots the execution times
for our algorithm for computing optimized gain sets
as the domain size is increased from 100,000 to
1 million
for a minConf
value of 0.5.
Note that
for this experiment,
we turned
off the bucketing
optimization
- so the running times would be even
smaller if we were to employ bucketing to reduce
the input size. The experiments validate our earlier
analytical
results on the O(M)
time complexity
of procedure
optGainlD.
As can be seen from
the figure, our optimized
gain set algorithm
scales
linearly with the domain size as well as k.

5.3
Sensitivity
to minConf
Figure
5(b) depicts
the running
times for our
algorithm
for a range of confidence values and a
domain size of 500,000. From the graphs, it follows
that the performance of procedure optGainlD
is not
affected by values for minconf.

6
Concluding
Remarks
In this paper, we generalized the optimized gain as-
sociation rule problem by permitting
rules to con-
tain upto k disjunctions
over one or two uninstanti-
ated numeric attributes.
For one attribute,
we pre-
sented an O(nk)
algorithm
for computing the opti-
mized gain rule, where n is the number of values in
the domain of the uninstantiated
attribute.
We also
presented a bucketing optimization
that coalesces
contiguous values - all of which have confidence ei-
ther greater than the minimum specified confidence
or less than the minimum
confidence.
For two
attributes,
we presented a dynamic programming
al-
gorithm
that computes approximate
gain rules -
we showed that the approximations
are within
a
constant factor of the optimized
rule using recent
results on binary space partitioning.
For a single
numeric attribute,
our experimental
results demon-
strate the effectiveness of our bucketing optimiza-
tion and the linear scale-up for our algorithm
for
computing optimized gain sets.


Acknowledgements:
We would like to thank
Narain Gehani, Hank Korth
and Avi Silberschatz
for their encouragement.
Without
the support of
Yesook Shim, it would have been impossible
to
complete this work.

References
[AF92]




[AIS93]




[AS941




[FMMTSSa]




[FMMT96b]




[HF95]




[KMP98]
F. D. Amore and P. G. Franciosa.
On
the optimal binary plane partition for sets
of isothetic
rectangles.
Information
Pro-
cessing Letters, 44(5):255-259,
December
1992.
Rakesh Agrawal,
Tomasz Imielinski,
and
Arun
Swami.
Mining
association
rules
between sets of items in large databases.
In Proc. of the ACM SIGMOD
Conference
on Management
of Data, pages 207-216,
Washington,
D.C., May 1993.
Rakesh
Agrawal and Ramakrishnan
Srikant.
Fast
algorithms
for mining association rules. In
Proc. of the VLDB
Conference, Santiago,
Chile, September
1994.
Takeshi
Fukuda,
Yasuhiko
Morimoto,
Shinichi
Morishita,
and Takesh Tokuyama.
Data mining us-
ing two-dimensional
optimized
association
rules:
Scheme, algorithms,
and visual-
ization.
In Proc. of the ACM SIGMOD
Conference on Management
of Data, June
1996.
Takeshi
Fukuda,
Yasuhiko
Morimoto,
Shinichi Morishita,
and Takesh
Tokuyama.
Mining
optimized
association
rules for numeric
attributes.
In Proc.
of the ACM SIGACT-SIGMOD-SIGART
Symposium on Principles
of Database Sys-
tems, June 1996.
J.
Han
and
Y.
Fu.
Discovery
of
multiple-level
association rules from large
databases.
In Proc. of the VLDB
Con-
ference,
Zurich,
Switzerland,
September
1995.
S. Khanna, S. Muthukrishnan,
and M. Pa-
terson. On approximating
rectangle tiling
and packing.
In Proc. 9th Annual
Sym-
posium on Discrete
Algorithms
(SODA),
pages 384-393, 1998.




143

200
K=50
-
140 -
K=50
-
-
K zz100 .+...
K = 100 .+...
K = 150 --0
120 -
K = 150 ,eo
150 -
_
o~-.------o---
Q.
m _...._..__...
*
_,___.,_,,,_,
q ____,,___,_

2
z
100
~~----------+---
.-......
+ _._______._
+ . .._____...
+____
_______
+
---
. . . . ..+._____....



it
E

i=
i=
60 -
5
5
`Z
`ii
3
a
60 -
i?
!i!
ti
`01,,,,,1,,j wEt, , , , , , 1
100
200
300
400
500
600
700
600
900
1000
0.2
0.3
0.4
0.5
0.6
0.7
0.6
0.9
Number
of Values (in thousands)
Minimum
Confidence
(minconf)
(a) Scale-up with n
(b) Sensitivity
to minConf

Figure 5: Performance Results


[MTV94]
Heikki
Mannila,
Hannu
Toivonen,
and
A. Inkeri
Verkamo.
Efficient
algorithms
for discovering association rules. In KDD-
94: AAAZ
Workshop on Knowledge
Dis-
covery in Databases, pages 181-192, Seat-
tle, Washington,
July 1994.

[PCY95]
Jong Soo Park,
Ming-Syan
Chen,
and
Philip
S. Yu. An effective hash based al-
gorithm
for mining
association
rules.
In
Proc.
of the ACM-SZGMOD
Conference
on Management
of Data, San Jose, Cal-
ifornia,
May 1995.

[RS98a]
R. Rastogi and K. Shim. Mining optimized
association
rules for categorical
and nu-
meric attributes.
In Znt'l Conference
on
Data Engineering,
Orlando,
1998.

[RS98b]
R. Rastogi and K. Shim. Mining optimized
gain rules numeric
attributes.
Technical
report,
Bell
Laboratories,
Murray
Hill,
1998.

[RS99]




[SASS]




[SASG]




[SON951
R. Rastogi and K. Shim. Mining optimized
support
rules for numeric
attributes.
In
Znt `1 Conference
on Data
Engineering,
Sydney, Austrailia,
1999.

Ramakrishnan
Srikant
and
Rakesh
Agrawal.
Mining
generalized
association
rules.
In Proc. of the VLDB
Conference,
Zurich, Switzerland,
September
1995.

Ramakrishnan
Srikant
and Rakesh Agrawal.
Mining quantitative
association rules in large relational
tables.
In Proc. of the ACM SZGMOD Conference
on Management
of Data, June 1996.

A. Savasere, E. Omiecinski,
and S. Na-
vathe.
An efficient algorithm
for mining
association
rules in large databases.
In
Proc. of the VLDB
Conference,
Zurich,
Switzerland,
September
1995.




144

